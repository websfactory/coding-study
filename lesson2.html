<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <title>몬스터를 피해 전설의 보물을 찾아라! 💎</title>
  <style>
    /* 기본 스타일 */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: 'Noto Sans KR', sans-serif;
    }

    body {
      background-color: #f5f7fa;
      font-size: 16px;
      line-height: 1.6;
      color: #333;
      overflow: hidden;
      height: 100%;
      min-height: 100dvh;
      min-height: -webkit-fill-available;
      position: relative;
    }
    
    html {
      height: 100%;
      min-height: 100dvh;
      min-height: -webkit-fill-available;
    }

    /* 동적 뷰포트 높이 설정 */
    :root {
      height: 100dvh;
      height: -webkit-fill-available;
    }
    
    /* CSS 변수로 뷰포트 높이 관리 */
    :root {
      --vh: 1vh;
    }
    
    /* 메인 컨테이너 */
    .container {
      display: flex;
      flex-direction: column;
      height: calc(var(--vh, 1vh) * 100);
      min-height: 100dvh;
      min-height: -webkit-fill-available;
      overflow: hidden;
      position: relative;
    }

    /* 위치 배경 */
    .location-bg {
      width: 100%;
      height: 180px;
      background-position: center;
      background-size: cover;
      background-repeat: no-repeat;
      position: relative;
      transition: all 1s ease;
      border-bottom: 5px solid #64B5F6;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    /* 캐릭터 스타일 */
    .character {
      font-size: 4rem;
      animation: bounce 2s infinite;
      filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
      z-index: 5;
    }
    
    @keyframes bounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }

    /* 위치 타이틀 */
    .location-title {
      position: absolute;
      bottom: 20px;
      left: 20px;
      background-color: rgba(0, 0, 0, 0.6);
      color: white;
      padding: 8px 16px;
      border-radius: 30px;
      font-weight: bold;
      font-size: 1.2rem;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    /* 채팅 영역 */
    .chat-container {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
      padding-bottom: 85px; /* 입력창 높이 + 여유 공간 */
      background-color: white;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    /* 메시지 스타일 */
    .message {
      max-width: 80%;
      padding: 12px 16px;
      border-radius: 18px;
      margin-bottom: 4px;
      position: relative;
      word-break: break-word;
      animation: fadeIn 0.3s forwards;
    }

    /* 메시지 페이드인 애니메이션 */
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    /* 코디 메시지 */
    .codi-message {
      align-self: flex-start;
      background-color: #E3F2FD;
      border-bottom-left-radius: 5px;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
    }

    /* 플레이어 메시지 */
    .player-message {
      align-self: flex-end;
      background-color: #E8F5E9;
      border-bottom-right-radius: 5px;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
    }

    /* 보낸 사람 이름 */
    .sender-name {
      font-weight: bold;
      margin-bottom: 4px;
      font-size: 0.9rem;
    }

    /* 입력 영역 */
    .input-container {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      padding: 12px;
      padding-bottom: calc(12px + env(safe-area-inset-bottom, 45px));
      background-color: white;
      border-top: 1px solid #e1e4e8;
      display: flex;
      align-items: center;
      gap: 10px;
      z-index: 1000;
      /* 브라우저 바 높이 고려 */
      bottom: calc(0px + (100vh - 100%));
      /* 구버전 iOS 지원 */
      padding-bottom: calc(12px + constant(safe-area-inset-bottom, 45px));
      padding-bottom: calc(12px + env(safe-area-inset-bottom, 45px));
    }

    /* 입력창 */
    .message-input {
      flex: 1;
      padding: 12px 16px;
      border: 2px solid #e1e4e8;
      border-radius: 24px;
      font-size: 1rem;
      outline: none;
      transition: border-color 0.3s;
    }

    .message-input:focus {
      border-color: #64B5F6;
    }

    .message-input:disabled {
      background-color: #f5f7fa;
      cursor: not-allowed;
    }

    /* 버튼 공통 스타일 */
    .btn {
      border: none;
      background-color: #2196F3;
      color: white;
      width: 46px;
      height: 46px;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 1.2rem;
      transition: background-color 0.3s, transform 0.2s;
      outline: none;
    }
    
    /* 모바일에서 제출 버튼 숨기기 */
    @media (max-width: 768px) {
      #sendBtn {
        display: none;
      }
    }

    .btn:hover {
      background-color: #1976D2;
      transform: scale(1.05);
    }

    .btn:active {
      transform: scale(0.95);
    }

    .btn:disabled {
      background-color: #B0BEC5;
      cursor: not-allowed;
      transform: none;
    }

    /* 백팩 버튼 */
    .backpack-btn {
      background-color: #4CAF50;
    }

    .backpack-btn:hover {
      background-color: #388E3C;
    }

    /* 선택지 스타일 */
    .options-container {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: 6px;
      margin-bottom: 10px;
    }

    .option-btn {
      background-color: #E8EAF6;
      color: #3F51B5;
      border: none;
      padding: 12px 20px;
      border-radius: 10px;
      cursor: pointer;
      font-size: 1rem;
      text-align: left;
      transition: background-color 0.3s, transform 0.2s;
      display: flex;
      align-items: center;
      font-weight: 500;
    }

    .option-btn:hover {
      background-color: #C5CAE9;
      transform: translateX(5px);
    }

    .option-btn:active {
      transform: translateX(2px);
    }

    /* 백팩 영역 */
    .backpack-container {
      position: fixed;
      bottom: calc(70px + env(safe-area-inset-bottom, 20px));
      right: 15px;
      background-color: white;
      padding: 15px;
      border-radius: 15px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
      min-width: 200px;
      z-index: 10;
      transform: translateY(20px);
      opacity: 0;
      transition: all 0.3s ease;
      pointer-events: none;
    }

    .backpack-container.show {
      transform: translateY(0);
      opacity: 1;
      pointer-events: all;
    }

    .backpack-title {
      font-weight: bold;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 8px;
      color: #333;
    }

    .backpack-items {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .item {
      background-color: #FFF9C4;
      color: #F57F17;
      padding: 6px 12px;
      border-radius: 30px;
      font-size: 0.9rem;
      animation: popIn 0.4s;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    @keyframes popIn {
      0% { transform: scale(0); }
      70% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }

    .empty-bag {
      color: #9E9E9E;
      font-style: italic;
    }

    /* 힌트 스타일 */
    .hint {
      background-color: #FFF8E1;
      border-left: 4px solid #FFC107;
      padding: 12px 16px;
      margin-top: 6px;
      margin-bottom: 10px;
      border-radius: 4px;
      animation: fadeIn 0.5s;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    /* 오류 메시지 스타일 */
    .error-message {
      color: #D32F2F;
      padding: 8px 12px;
      border-radius: 4px;
      margin-top: 4px;
      margin-bottom: 6px;
      background-color: #FFEBEE;
      font-size: 0.9rem;
      display: flex;
      align-items: center;
      gap: 8px;
      animation: shake 0.5s;
    }

    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      20%, 60% { transform: translateX(-5px); }
      40%, 80% { transform: translateX(5px); }
    }

    /* 성공 메시지 스타일 */
    .success-message {
      color: #388E3C;
      padding: 8px 12px;
      border-radius: 4px;
      margin-top: 4px;
      margin-bottom: 6px;
      background-color: #E8F5E9;
      font-size: 0.9rem;
      display: flex;
      align-items: center;
      gap: 8px;
      animation: popIn 0.5s;
    }

    /* 로딩 효과 */
    .typing-indicator {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 8px 12px;
      background-color: #E3F2FD;
      border-radius: 18px;
      width: fit-content;
      margin-bottom: 6px;
    }

    .typing-dot {
      width: 8px;
      height: 8px;
      background-color: #64B5F6;
      border-radius: 50%;
      animation: typingBounce 1.4s infinite ease-in-out;
    }

    .typing-dot:nth-child(1) { animation-delay: 0s; }
    .typing-dot:nth-child(2) { animation-delay: 0.2s; }
    .typing-dot:nth-child(3) { animation-delay: 0.4s; }

    @keyframes typingBounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-5px); }
    }

    /* 정답 입력 스타일 */
    .correct-answer {
      color: #388E3C;
      font-weight: bold;
    }

    /* 코드 태그 스타일 */
    code {
      background-color: #f5f5f5;
      border: 1px solid #e0e0e0;
      border-radius: 4px;
      padding: 2px 6px;
      font-family: 'Courier New', monospace;
      font-size: 0.9em;
      color: #d32f2f;
      font-weight: bold;
    }

    /* 프로그레스 바 */
    .progress-container {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 5px;
      background-color: rgba(255, 255, 255, 0.3);
    }

    .progress-bar {
      height: 100%;
      background-color: #4CAF50;
      transition: width 0.5s ease;
    }
    
    /* Safari 버그 해결을 위한 빈 고정 요소 */
    .safari-fix {
      position: fixed;
      top: 0;
      left: 0;
      width: 1px;
      height: 1px;
    }
    
    /* 모바일 대응 추가 스타일 */
    @supports (padding-bottom: env(safe-area-inset-bottom)) {
      .input-container {
        padding-bottom: calc(12px + env(safe-area-inset-bottom, 45px));
        bottom: env(safe-area-inset-bottom, 0);
      }
    }
    
    /* 동적 뷰포트 높이 지원 브라우저 */
    @supports (height: 100dvh) {
      .container {
        min-height: 100dvh;
        height: 100dvh;
      }
    }
    
    /* 작은 화면에서 백팩 버튼 위치 조정 */
    @media (max-height: 600px) {
      .backpack-container {
        bottom: calc(120px + env(safe-area-inset-bottom, 45px));
      }
      
      .chat-container {
        padding-bottom: 105px;
      }
    }
    
    /* iOS 키보드 대응 */
    @supports (-webkit-touch-callout: none) {
      .input-container {
        position: fixed;
        bottom: 0;
        transform: translateZ(0);
        -webkit-transform: translateZ(0);
        will-change: transform;
      }
    }
  </style>
</head>
<body>
  <!-- Safari 버그 해결을 위한 빈 고정 요소 -->
  <div class="safari-fix"></div>
  
  <div class="container">
    <!-- 위치 배경 영역 -->
    <div class="location-bg" id="locationBg">
      <div class="character" id="locationCharacter">🤖</div>
      <div class="location-title" id="locationTitle">👋 파이썬 탐험대의 신비한 여행</div>
      <div class="progress-container">
        <div class="progress-bar" id="progressBar" style="width: 0%"></div>
      </div>
    </div>

    <!-- 채팅 영역 -->
    <div class="chat-container" id="chatContainer"></div>

    <!-- 입력 영역 -->
    <div class="input-container">
      <input type="text" class="message-input" id="messageInput" placeholder="메시지를 입력하세요...">
      <button class="btn" id="sendBtn">📤</button>
      <button class="btn backpack-btn" id="backpackBtn">🎒</button>
    </div>
  </div>

  <!-- 백팩 컨테이너 -->
  <div class="backpack-container" id="backpackContainer">
    <div class="backpack-title">🎒 내가방</div>
    <div class="backpack-items" id="backpackItems">
      <div class="empty-bag">가방이 비어있어요</div>
    </div>
  </div>

  <script>
    // 동적 뷰포트 높이 설정 - 모바일 브라우저 바 대응
    function setViewportHeight() {
      const vh = window.innerHeight * 0.01;
      document.documentElement.style.setProperty('--vh', `${vh}px`);
    }
    
    // 초기 설정 및 리사이즈 이벤트
    setViewportHeight();
    window.addEventListener('resize', setViewportHeight);
    window.addEventListener('orientationchange', setViewportHeight);
    
    // Visual Viewport API 사용 (지원하는 경우)
    if ('visualViewport' in window) {
      window.visualViewport.addEventListener('resize', () => {
        const height = window.visualViewport.height;
        const bottomOffset = window.innerHeight - height;
        const inputContainer = document.querySelector('.input-container');
        if (inputContainer) {
          inputContainer.style.bottom = `${bottomOffset}px`;
        }
      });
    }
    
    // DOM 요소
    const chatContainer = document.getElementById('chatContainer');
    const messageInput = document.getElementById('messageInput');
    const sendBtn = document.getElementById('sendBtn');
    const backpackBtn = document.getElementById('backpackBtn');
    const backpackContainer = document.getElementById('backpackContainer');
    const backpackItems = document.getElementById('backpackItems');
    const locationBg = document.getElementById('locationBg');
    const locationTitle = document.getElementById('locationTitle');
    const locationCharacter = document.getElementById('locationCharacter');
    const progressBar = document.getElementById('progressBar');

    // 게임 상태 객체
    const game = {
      playerName: '',
      currentStage: 'intro',
      bag: [],
      isTyping: false,
      lastPoppedItem: null, // pop으로 꺼낸 아이템 임시 저장
      
      // 백팩 업데이트
      updateBackpack: function() {
        if (this.bag.length === 0) {
          backpackItems.innerHTML = '<div class="empty-bag">가방이 비어있어요</div>';
          return;
        }

        backpackItems.innerHTML = '';
        this.bag.forEach(item => {
          const itemElement = document.createElement('div');
          itemElement.className = 'item';
          const emoji = itemEmojis[item] || '❓'; 
          itemElement.textContent = `${emoji} ${item}`;
          backpackItems.appendChild(itemElement);
        });
      },
      
      // 코디 메시지 추가
      addCodiMessage: function(text, callback) {
        if (this.isTyping) {
          return;
        }
        
        this.isTyping = true;
        messageInput.disabled = true; 
        sendBtn.disabled = true; 
        
        const typingIndicator = document.createElement('div');
        typingIndicator.className = 'typing-indicator';
        typingIndicator.innerHTML = `
          <div class="typing-dot"></div>
          <div class="typing-dot"></div>
          <div class="typing-dot"></div>
        `;
        chatContainer.appendChild(typingIndicator);
        scrollToBottom();
        
        setTimeout(() => {
          if (typingIndicator.parentNode === chatContainer) {
            chatContainer.removeChild(typingIndicator);
          }
          
          const messageElement = document.createElement('div');
          messageElement.className = 'message codi-message';
          
          const senderElement = document.createElement('div');
          senderElement.className = 'sender-name';
          senderElement.textContent = '코디 🤖';
          
          const textElement = document.createElement('div');
          textElement.innerHTML = ''; 
          
          messageElement.appendChild(senderElement);
          messageElement.appendChild(textElement);
          chatContainer.appendChild(messageElement);
          
          let i = 0;
          const typingSpeed = 20; 
          
          const typeChar = () => {
            if (i < text.length) {
              if (text.substring(i).startsWith('<br>')) {
                textElement.innerHTML += '<br>';
                i += 4; 
              } else {
                textElement.innerHTML += text.charAt(i);
                i++;
              }
              scrollToBottom();
              setTimeout(typeChar, typingSpeed);
            } else {
              this.isTyping = false;
              if (!this.isOptionStage(this.currentStage) && !(callback && this.isCallbackLeadingToOptions(this.currentStage))) {
                 if(this.currentStage !== 'ending_treasure' && this.currentStage !== 'codi_farewell_soon') { 
                    messageInput.disabled = false;
                    sendBtn.disabled = false;
                 }
              }
              if (callback) {
                setTimeout(callback, 300); 
              }
            }
          };
          
          typeChar();
        }, 500); 
      },

      isOptionStage: function(stageName) {
        const optionStages = ['intro_confirm_start', 'ending_treasure']; 
        return optionStages.includes(stageName);
      },

      isCallbackLeadingToOptions: function(stageName) {
        return false;
      },
      
      addPlayerMessage: function(text) {
        const messageElement = document.createElement('div');
        messageElement.className = 'message player-message';
        
        const senderElement = document.createElement('div');
        senderElement.className = 'sender-name';
        senderElement.textContent = this.playerName || '탐험가 🌟'; 
        
        const textElement = document.createElement('div');
        textElement.textContent = text;
        
        messageElement.appendChild(senderElement);
        messageElement.appendChild(textElement);
        chatContainer.appendChild(messageElement);
        
        scrollToBottom();
      },
      
      addOptions: function(options, correctOption, nextStageOrCallback) {
        const optionsContainer = document.createElement('div');
        optionsContainer.className = 'options-container';
        
        messageInput.disabled = true; 
        messageInput.placeholder = '선택지를 골라주세요...';
        sendBtn.disabled = true;
        
        options.forEach(optionText => { 
          const optionBtn = document.createElement('button');
          optionBtn.className = 'option-btn';
          optionBtn.textContent = optionText;
          
          optionBtn.addEventListener('click', () => {
            document.querySelectorAll('.option-btn').forEach(btn => {
              btn.disabled = true;
              btn.style.opacity = 0.5;
            });
            
            optionBtn.style.opacity = 1;
            optionBtn.style.backgroundColor = '#C5CAE9'; 
            
            this.addPlayerMessage(optionText);
            
            setTimeout(() => {
              if (optionsContainer.parentNode === chatContainer) { 
                  chatContainer.removeChild(optionsContainer);
              }
              
              if (optionText === correctOption) {
                if (typeof nextStageOrCallback === 'string') {
                  this.showSuccess('좋아! 선택 완료!'); 
                  setTimeout(() => this.goToStage(nextStageOrCallback), 1000);
                } else if (typeof nextStageOrCallback === 'function') {
                   this.showSuccess('좋아! 선택 완료!');
                   setTimeout(nextStageOrCallback.bind(this, optionText), 1000); // 콜백에 선택된 옵션 전달 및 this 바인딩
                }
              } else {
                this.showDetailedError("음... 그 선택은 아닌 것 같아. 다시 한번 골라볼까?", this.currentStage); 
              }
            }, 500);
          });
          
          optionsContainer.appendChild(optionBtn);
        });
        
        chatContainer.appendChild(optionsContainer);
        scrollToBottom();
      },
      
      handleCustomInput: function(input, correctAnswerOrValidator, nextStageOrCallback, failureMessage) {
        let isValid = false;
        let validationResult = { success: false };

        if (typeof correctAnswerOrValidator === 'function') {
            validationResult = correctAnswerOrValidator(input);
            isValid = validationResult.success;
        } else if (typeof correctAnswerOrValidator === 'string') {
            // 공백을 무시하고 비교하여 띄어쓰기 차이를 허용
            const normalizeString = (str) => str.replace(/\s+/g, '').toLowerCase();
            if (normalizeString(input) === normalizeString(correctAnswerOrValidator)) {
                isValid = true;
            }
        }

        if (isValid) {
          const commandSuccessful = this.executeCommand(input); 
          if (commandSuccessful === false) { 
            if (failureMessage) {
                 this.showDetailedError(failureMessage, this.currentStage);
            } else if (validationResult && validationResult.message) {
                 this.showDetailedError(validationResult.message, this.currentStage);
            }
            return; 
          }
          this.showSuccess(); // executeCommand 성공 후 메시지 표시

          if (typeof nextStageOrCallback === 'string') {
            setTimeout(() => this.goToStage(nextStageOrCallback), 1000);
          } else if (typeof nextStageOrCallback === 'function') {
            setTimeout(() => nextStageOrCallback(this.lastPoppedItem), 1000); 
          }
        } else {
          let errMsg = failureMessage || (validationResult && validationResult.message) || "명령어를 다시 한번 확인해줄래? 🧐";
          this.showDetailedError(errMsg, this.currentStage); 
        }
      },
      
      executeCommand: function(command) {
        try {
            const appendRegex = /^내가방\.append\(\s*['"](.+?)['"]\s*\)$/;
            const removeRegex = /^내가방\.remove\(\s*['"](.+?)['"]\s*\)$/;
            const insertRegex = /^내가방\.insert\(\s*(\d+)\s*,\s*['"](.+?)['"]\s*\)$/;
            const popRegex = /^(?:(\w+)\s*=\s*)?내가방\.pop\(\s*(\d+)\s*\)$/;
            const lenRegex = /^len\(\s*내가방\s*\)$/;

            let match;

            if ((match = command.match(appendRegex))) {
                const item = match[1];
                this.bag.push(item);
                this.updateBackpack();
                // this.addCodiMessage(`✅ '${item}'(을)를 가방에 넣었어!`); // 성공 메시지는 handleCustomInput에서 통합
            } else if ((match = command.match(removeRegex))) {
                const item = match[1];
                const itemIndex = this.bag.indexOf(item);
                if (itemIndex > -1) {
                    this.bag.splice(itemIndex, 1);
                    this.updateBackpack();
                } else {
                    this.showDetailedError(`⚠️ '${item}'(은)는 가방에 없는 것 같아. 백팩을 확인해볼까?`, this.currentStage);
                    return false; 
                }
            } else if ((match = command.match(insertRegex))) {
                const index = parseInt(match[1]);
                const item = match[2];
                if (index >= 0 && index <= this.bag.length) { 
                    this.bag.splice(index, 0, item);
                    this.updateBackpack();
                    // this.addCodiMessage(`✅ '${item}'(을)를 ${index}번 칸에 넣었어! (현재 가방: ${JSON.stringify(this.bag).replace(/","/g, "', '")})`);
                } else {
                    this.showDetailedError(`⚠️ ${index}번 칸은 없는 위치야. 0부터 ${this.bag.length - 1}까지의 숫자만 사용할 수 있어.`, this.currentStage);
                    return false; 
                }
            } else if ((match = command.match(popRegex))) {
                const variableName = match[1]; // 변수 이름 (예: 선물)
                const index = parseInt(match[2]); // 인덱스

                if (index >= 0 && index < this.bag.length) {
                    const poppedItem = this.bag.splice(index, 1)[0];
                    this.lastPoppedItem = poppedItem; 
                    this.updateBackpack();
                    // this.addCodiMessage(`✅ ${index}번 칸에서 '${poppedItem}'(을)를 꺼냈어! ${(variableName ? `'${variableName}' 변수에 '${poppedItem}'(이)가 담겼어!` : '')}`);
                } else {
                     if (this.bag.length === 0) {
                        this.showDetailedError("⚠️ 가방이 비어 있어서 아무것도 꺼낼 수 없어!", this.currentStage);
                    } else {
                        this.showDetailedError(`⚠️ ${index}번 칸은 없는 위칸야. 0부터 ${this.bag.length - 1}까지의 숫자만 사용할 수 있어.`, this.currentStage);
                    }
                    return false; 
                }
            } else if (lenRegex.test(command)) {
                this.addCodiMessage(`ℹ️ 가방에는 현재 ${this.bag.length}개의 아이템이 있어!`);
            } else {
                // 유효성 검사를 통과한 단순 문자열(선택지 등)일 경우, 또는 알 수 없는 명령어.
                // handleCustomInput에서 이미 오류 처리를 하므로 여기서는 true 반환.
                return true; 
            }
            return true; 
        } catch (error) {
            console.error("명령어 실행 중 오류:", error);
            this.showDetailedError("앗! 명령어를 실행하는 중에 문제가 생겼어. 다시 시도해 줄래?", this.currentStage);
            return false; 
        }
      },
      
      showSuccess: function(message = '✅ 정확해! 잘했어!') { 
        const successElement = document.createElement('div');
        successElement.className = 'success-message';
        successElement.innerHTML = message; 
        chatContainer.appendChild(successElement);
        scrollToBottom();
      },
      
      showDetailedError: function(errorMessage, stageToRetry) {
        const errorElement = document.createElement('div');
        errorElement.className = 'error-message';
        errorElement.innerHTML = `🤷 ${errorMessage}`; 
        chatContainer.appendChild(errorElement);
        scrollToBottom();

        messageInput.disabled = false;
        messageInput.placeholder = '다시 입력해보세요...';
        sendBtn.disabled = false;
      },

      showError: function() { 
        this.showDetailedError('❌ 아쉽게도 틀렸어! 다시 도전해볼까요?', this.currentStage);
      },
      
      goToStage: function(stageName) {
        this.currentStage = stageName;
        messageInput.disabled = false; 
        messageInput.placeholder = '파이썬 명령어를 입력하세요...';
        sendBtn.disabled = false;
        
        switch(stageName) {
          case 'intro':
            updateLocation('start', 0); 
            this.addCodiMessage('안녕! 👋 다시 만나 반가워! 지난번엔 파이썬 리스트의 기초를 배웠었지.<br>이번엔 "몬스터를 피해 전설의 보물을 찾아라! 💎" 모험을 떠날 거야.<br>시작하기 전에, 네 이름이 뭐였더라? 다시 한번 알려줄래?', () => {
              messageInput.placeholder = '이름을 입력하세요...';
            });
            break;
            
          case 'intro_confirm_start': 
            updateLocation('adventure_start', 5); 
            this.addCodiMessage(`${this.playerName || '탐험가'}아(야), 정말 반가워! 🤩<br>이번 모험에서도 마법 가방 '내가방'을 사용할 거야. <code>내가방 = []</code> 이렇게 비어있는 상태로 시작하자!`, () => {
              this.bag = []; 
              this.updateBackpack();
              this.addCodiMessage('자, 그럼 전설의 보물을 찾으러 출발할 준비 됐니?', () => {
                this.addOptions(
                  ['네, 준비됐어요! 보물을 찾으러 가요! 🚀'], 
                  '네, 준비됐어요! 보물을 찾으러 가요! 🚀',
                  'stage1_forest_intro'
                );
              });
            });
            break;
            
          case 'stage1_forest_intro':
            updateLocation('forest', 10); 
            this.addCodiMessage('좋아! 우리는 "속삭이는 숲"에 도착했어. 🌲<br>이곳을 안전하게 지나가려면 아이템이 필요해.', () => {
              this.addCodiMessage("'등불'로 길을 밝히고, '열매'로 허기를 달래야 해.<br>먼저 '등불'을 가방에 넣어볼까?<br>(힌트: <code>내가방.append(\'아이템이름\')</code> 기억나지? 'a'로 시작해!)", () => {
                messageInput.placeholder = "append 명령어를 사용해보세요...";
              });
            });
            break;

          case 'stage1_forest_append_berry':
            this.addCodiMessage("💡 '등불'이 가방에 쏙! (백팩 UI 확인!)<br>로블록스 게임에서 인벤토리에 아이템 넣는 거랑 똑같지? 😉", () => {
              this.addCodiMessage("이제 '열매'도 가방에 넣어보자! 같은 방법이야.", () => {
                messageInput.placeholder = "append 명령어로 열매를 추가하세요...";
              });
            });
            break;

          case 'stage1_forest_len':
            this.addCodiMessage("🍓 '열매'도 성공적으로 추가! 가방이 든든해졌는걸?<br>지금 가방에 아이템이 총 몇 개 있는지 확인해볼까?", () => {
              this.addCodiMessage("(힌트: 전체 개수는 'l'로 시작하는 짧은 명령어! <code>len(내가방)</code> 기억나지?)", () => {
                messageInput.placeholder = "len 명령어를 입력하세요...";
              });
            });
            break;

          case 'stage2_cave_intro':
            updateLocation('cave_bridge', 30); 
            this.addCodiMessage(`맞아! 가방에는 총 ${this.bag.length}개의 아이템이 있어!<br><code>len()</code> 명령어는 나중에 로블록스에서 친구 목록 수나 스킬 개수 셀 때도 유용할 거야!`, () => {
              this.addCodiMessage("으악! 😱 저 앞에 '흔들리는 동굴 다리'가 나타났어!<br>다리가 너무 낡아서, 가방에서 가장 무거워 보이는 '등불'을 잠시 내려놓고 가야겠어.", () => {
                this.addCodiMessage("가방에서 아이템을 없앨 때는 어떤 명령어를 썼더라?<br>(힌트: 'r'로 시작해! <code>내가방.remove(\'아이템이름\')</code> 형식이야!)", () => {
                  messageInput.placeholder = "remove 명령어를 사용해보세요...";
                });
              });
            });
            break;
          
          case 'stage2_cave_after_remove':
            this.addCodiMessage("휴, 다행이다! 💡 '등불'을 내려놓으니 가방이 가벼워져서 안전하게 건넜어!", () => {
              this.addCodiMessage("지금 가방엔 뭐가 남았는지 <code>len(내가방)</code>으로 다시 확인해볼까?", () => {
                messageInput.placeholder = "len 명령어로 개수를 확인하세요...";
              });
            });
            break;

          case 'stage3_altar_intro':
            updateLocation('altar', 50); 
            if (!this.bag.includes('물의 수정')) this.bag.push('물의 수정');
            if (!this.bag.includes('바람의 수정')) this.bag.push('바람의 수정');
            this.updateBackpack();

            this.addCodiMessage(`좋아, 가방엔 이제 ${this.bag.length}개의 아이템만 남았네!<br>우리는 '비밀의 제단'에 도착했어. 🏛️`, () => {
              this.addCodiMessage("제단에는 3개의 홈이 파여 있고, 순서대로 '물의 수정', '불의 수정', '바람의 수정'을 끼워야 문이 열린대.<br>우리 가방을 볼까? (현재 내가방: [" + this.bag.map(item => `'${item}'`).join(", ") + "])", () => {
                this.addCodiMessage("이런! '불의 수정'이 없네! 저기 반짝이는 게 '불의 수정'인 것 같아! 어서 주워오자!<br><code>내가방.append(\'불의 수정\')</code>을 입력해서 '불의 수정'을 가방에 넣어줘.", () => {
                  messageInput.placeholder = "append 명령어로 불의 수정을 추가하세요...";
                });
              });
            });
            break;

          case 'stage3_altar_check_order':
            this.addCodiMessage("🔥 '불의 수정'을 가방에 넣었어! (현재 내가방: [" + this.bag.map(item => `'${item}'`).join(", ") + "])", () => {
              this.addCodiMessage("그런데 순서가 안 맞네.<br>'물의 수정' 다음, 즉 두 번째에는 '불의 수정'이 들어가야 하는데, 지금은 맨 뒤에 있어.<br>파이썬에서 리스트의 칸 번호는 0번부터 시작해. 그래서 '물의 수정'은 0번 칸, 그 다음이 1번 칸, 마지막이 2번 칸이야.", () => {
                this.addCodiMessage("먼저 맨 뒤에 있는 '불의 수정'을 <code>내가방.pop(2)</code>로 빼볼까? (가장 뒤에 있으니 2번 칸이야)<br>그 다음에 <code>내가방.insert(1, '불의 수정')</code>으로 1번 칸에 넣어주면 완벽해!", () => {
                   this.addCodiMessage("자, 먼저 <code>내가방.pop(2)</code>를 입력해서 '불의 수정'을 잠시 꺼내보자!", () => {
                     messageInput.placeholder = "pop 명령어를 사용해보세요...";
                   });
                });
              });
            });
            break;
            
          case 'stage3_altar_after_pop':
            this.addCodiMessage("좋아! '불의 수정'을 가방에서 잠시 꺼냈어. (현재 내가방: [" + this.bag.map(item => `'${item}'`).join(", ") + "])", () => {
                this.addCodiMessage("이제 특별한 끼워넣기 마법을 배워보자! 🪄<br>마치 친구들 사이에 끼어들 듯이, 아이템을 원하는 자리에 쏙 넣을 수 있어!<br><br>지금 가방엔 [0번: 물의 수정, 1번: 바람의 수정]이 있지?<br>'불의 수정'을 1번 자리에 넣으면, '바람의 수정'은 뒤로 밀려나게 돼!<br><br>명령어: <code>내가방.insert(1, '불의 수정')</code><br>이렇게 하면 → [0번: 물의 수정, 1번: 불의 수정, 2번: 바람의 수정]", () => {
                    messageInput.placeholder = "insert 명령어를 사용해보세요...";
                });
            });
            break;

          case 'stage3_altar_success':
            updateLocation('altar_gate_open', 70); 
            this.addCodiMessage("완벽해! 💎 순서가 딱 맞았어! (현재 내가방: [" + this.bag.map(item => `'${item}'`).join(", ") + "])<br>비밀의 문이 스르륵 열린다!", () => {
              this.addCodiMessage("이 <code>insert</code> 마법은 로블록스에서 아이템 목록의 순서를 바꾸거나, 채팅 메시지를 중간에 끼워넣을 때 정말 유용해!", () => {
                  this.goToStage('stage4_monster_intro');
              });
            });
            break;

          case 'stage4_monster_intro':
            updateLocation('monster_lair', 75); 
            this.addCodiMessage("문 너머에는 보물 창고가 있지만... 👾 이런! 길을 막고 있는 몬스터가 나타났어!<br>다행히 나쁜 몬스터는 아닌 것 같아.", () => {
              this.addCodiMessage("몬스터가 말하길, '네 가방의 첫 번째 아이템을 나에게 선물로 주면 길을 비켜주겠다!' 라고 하네.<br>첫 번째 아이템은 0번 칸에 있는 아이템이야.", () => {
                this.addCodiMessage("이번엔 <code>pop</code>이라는 마법을 써보자!<br><code>꺼낸아이템 = 내가방.pop(위치번호)</code> 이렇게 사용하면 특정 위치의 아이템을 꺼내면서, 그 아이템을 '꺼낸아이템'이라는 곳에 잠시 보관할 수 있어. 가방에서는 그 아이템이 사라지고!", () => {
                  this.addCodiMessage("자, <code>선물 = 내가방.pop(0)</code> 또는 간단히 <code>내가방.pop(0)</code>을 입력해서 첫 번째 아이템을 꺼내 몬스터에게 줄 준비를 하자!", () => {
                    messageInput.placeholder = "pop 명령어로 첫 번째 아이템을 꺼내세요...";
                  });
                });
              });
            });
            break;

          case 'stage4_monster_gift':
            if (this.lastPoppedItem) {
                const giftEmoji = itemEmojis[this.lastPoppedItem] || '❓';
                this.addCodiMessage(`좋아! ${giftEmoji} '${this.lastPoppedItem}'(을)를 꺼냈어. 이제 이 선물을 몬스터에게 건네주자!`, () => {
                    this.addCodiMessage("몬스터가 선물을 받고는 아주 기뻐하며 길을 비켜줬어! 🥳<br><code>pop</code> 마법 덕분이야! 이 마법은 게임에서 아이템을 사용하면 인벤토리에서 사라지게 할 때 쓸 수 있겠지?", () => {
                        this.goToStage('ending_treasure');
                    });
                });
            } else {
                this.addCodiMessage("어라? 몬스터에게 줄 아이템이 준비되지 않은 것 같아. 이전 단계로 돌아가서 다시 해볼까?", () => {
                    this.goToStage('stage4_monster_intro'); 
                });
            }
            updateLocation('monster_cleared', 90); 
            break;
            
          case 'ending_treasure':
            updateLocation('treasure_room', 100); 
            this.addCodiMessage(`드디어 전설의 보물을 찾았어, ${this.playerName || '예린'} 탐험가! 🏆✨ 정말 대단해!`, () => {
              this.addCodiMessage("너는 이제 파이썬 리스트 마법을 자유자재로 사용하는 멋진 모험가가 되었어!", () => {
                this.addCodiMessage("<code>append</code>로 아이템 추가하기, <code>remove</code>로 아이템 없애기, <code>len</code>으로 개수 확인하기, <code>insert</code>로 원하는 곳에 끼워넣기, <code>pop</code>으로 특정 아이템 꺼내기까지! 모두 완벽하게 익혔는걸!", () => {
                  this.addCodiMessage("이 모든 건 로블록스 게임을 만들 때 캐릭터의 능력치, 친구 목록, 인벤토리 아이템들을 관리하는 데 아주 유용하게 쓰일 수 있는 기술들이야.<br>앞으로 네가 만들 멋진 게임들이 기대되는걸! 😉", () => {
                    this.addOptions(
                      ['다시 모험하기 🔄', '다른 마법 배우러 가기 (준비중) 🚧'],
                      '다시 모험하기 🔄', 
                      (selectedOption) => { 
                        if (selectedOption === '다시 모험하기 🔄') {
                          this.goToStage('restart');
                        } else {
                          this.goToStage('codi_farewell_soon');
                        }
                      }
                    );
                    messageInput.disabled = true; 
                    sendBtn.disabled = true;
                  });
                });
              });
            });
            break;

          case 'codi_farewell_soon':
            this.addCodiMessage("좋아! 다음 모험도 곧 준비될 거야. 그때 다시 만나자! 👋");
            messageInput.disabled = true;
            messageInput.placeholder = '다음에 또 만나요!';
            sendBtn.disabled = true;
            break;
            
          case 'restart':
            this.reset();
            break;
        }
      },
      
      reset: function() {
        this.playerName = ''; 
        this.bag = [];
        this.lastPoppedItem = null;
        
        chatContainer.innerHTML = ''; 
        messageInput.disabled = false;
        messageInput.placeholder = '메시지를 입력하세요...';
        sendBtn.disabled = false;
        
        this.updateBackpack();
        this.goToStage('intro'); 
      },
      
      handleInput: function(input) {
        if (!input.trim()) return;
        
        this.addPlayerMessage(input); 
        messageInput.value = ''; 

        const currentStage = this.currentStage; 

        if (currentStage === 'intro') {
          this.playerName = input;
          this.goToStage('intro_confirm_start');
        } else if (currentStage === 'stage1_forest_intro') {
          this.handleCustomInput(input, "내가방.append('등불')", 'stage1_forest_append_berry', "앗! '등불'을 추가하는 정확한 명령어는 <code>내가방.append(\'등불\')</code>이야. 따옴표와 괄호를 잘 확인해봐! 😉");
        } else if (currentStage === 'stage1_forest_append_berry') {
          this.handleCustomInput(input, "내가방.append('열매')", 'stage1_forest_len', "좋아, '열매'를 추가하는 주문은 <code>내가방.append(\'열매\')</code>야. 거의 다 왔어!");
        } else if (currentStage === 'stage1_forest_len') {
          this.handleCustomInput(input, "len(내가방)", () => { 
            this.goToStage('stage2_cave_intro');
          }, "<code>len(내가방)</code>이 정확한 주문이야! 괄호 안에 '내가방'을 넣는 것 잊지 않았지?");
        } else if (currentStage === 'stage2_cave_intro') {
          this.handleCustomInput(input, "내가방.remove('등불')", 'stage2_cave_after_remove', "'등불'을 없애려면 <code>내가방.remove(\'등불\')</code>이라고 외쳐야 해. 가방에 해당 아이템이 있는지도 확인해봐! 🎒");
        } else if (currentStage === 'stage2_cave_after_remove') {
           this.handleCustomInput(input, "len(내가방)", () => {
            this.goToStage('stage3_altar_intro');
          }, "가방 안의 아이템 개수는 <code>len(내가방)</code>으로 확인할 수 있어!");
        } else if (currentStage === 'stage3_altar_intro') {
            this.handleCustomInput(input, "내가방.append('불의 수정')", 'stage3_altar_check_order', "<code>내가방.append(\'불의 수정\')</code>을 입력해서 불의 수정을 가방에 넣어줘!");
        } else if (currentStage === 'stage3_altar_check_order') {
            this.handleCustomInput(input, "내가방.pop(2)", 'stage3_altar_after_pop', "'불의 수정'을 제거하는 명령어를 입력해줘! <code>내가방.pop(2)</code>를 사용해야 해.");
        } else if (currentStage === 'stage3_altar_after_pop') {
            this.handleCustomInput(input, "내가방.insert(1, '불의 수정')", 'stage3_altar_success', "<code>내가방.insert(1, \'불의 수정\')</code>이 정확한 주문이야! 위치 숫자 1과 '불의 수정'을 쉼표로 구분하고, 아이템 이름엔 따옴표! 😉");
        } else if (currentStage === 'stage4_monster_intro') {
            this.handleCustomInput(input, (cmd) => { 
                const popRegex = /^(?:(\w+)\s*=\s*)?내가방\.pop\(\s*0\s*\)$/;
                if (popRegex.test(cmd)) { 
                    if (this.bag.length > 0 && this.bag[0]) { 
                        return { success: true };
                    } else {
                        return { success: false, message: "⚠️ 가방이 비어있거나 첫 번째 아이템이 없어! 몬스터에게 줄 게 없네..." };
                    }
                }
                return { success: false, message: "몬스터에게 첫 번째 아이템을 주려면 <code>내가방.pop(0)</code> 또는 <code>선물 = 내가방.pop(0)</code>을 입력해야 해. 0번 칸을 정확히 지정했는지 확인해봐! 🤓" };
            }, 'stage4_monster_gift');
        }
      }
    };

    const locations = {
      start: { 
        bg: 'linear-gradient(to bottom, #a0c4ff 0%, #c1d8ff 100%)', 
        title: '💎 보물찾기 모험 시작!',
        character: '🗺️' 
      },
      adventure_start: { 
        bg: 'linear-gradient(to bottom, #b3e0ff 0%, #d1eeff 100%)', 
        title: '✨ 새로운 모험 준비!',
        character: '🧑‍🚀' 
      },
      forest: {
        bg: 'linear-gradient(to bottom, #90ee90 0%, #c3f3c3 100%)', 
        title: '🌲 속삭이는 숲',
        character: '🦋' 
      },
      cave_bridge: {
        bg: 'linear-gradient(to bottom, #bcaaa4 0%, #d7ccc8 100%)', 
        title: '🌉 흔들리는 동굴 다리',
        character: '😨' 
      },
      altar: {
        bg: 'linear-gradient(to bottom, #fff59d 0%, #fff9c4 100%)', 
        title: '🏛️ 비밀의 제단',
        character: '💎' 
      },
      altar_gate_open: { 
        bg: 'linear-gradient(to bottom, #ffe082 0%, #fff1b8 100%)',
        title: '🌟 문이 열렸다!',
        character: '✨'
      },
      monster_lair: {
        bg: 'linear-gradient(to bottom, #ffab91 0%, #ffccbc 100%)', 
        title: '👾 몬스터의 시험',
        character: '👹' 
      },
      monster_cleared: { 
        bg: 'linear-gradient(to bottom, #c5e1a5 0%, #e6ee9c 100%)',
        title: '😅 휴, 지나갔다!',
        character: '🥳'
      },
      treasure_room: { 
        bg: 'linear-gradient(to bottom, #ffd700 0%, #fffacd 100%)', 
        title: '🏆 전설의 보물 발견!',
        character: '🎉'
      }
    };

    const itemEmojis = {
      '등불': '💡',
      '열매': '🍓',
      '물의 수정': '💧',
      '불의 수정': '🔥',
      '바람의 수정': '🌬️',
      '물병': '🍼', 
      '지도': '🗺️',
      '손전등': '🔦',
      '수영복': '🩱',
      '물': '💦',
      '모자': '👒',
      '선크림': '🧴',
      '로프': '🧵'
    };

    function updateLocation(locationKey, progress) {
      const location = locations[locationKey];
      if (location) { 
        locationBg.style.background = location.bg;
        locationTitle.textContent = location.title;
        locationCharacter.textContent = location.character;
        progressBar.style.width = `${progress}%`;
      } else {
        console.warn(`Location key "${locationKey}" not found in locations object.`);
        locationBg.style.background = 'linear-gradient(to bottom, #cccccc 0%, #999999 100%)';
        locationTitle.textContent = '알 수 없는 장소';
        locationCharacter.textContent = '❓';
      }
    }

    function scrollToBottom() {
      setTimeout(() => {
        chatContainer.scrollTop = chatContainer.scrollHeight;
      }, 10); 
    }

    function toggleBackpack() {
      backpackContainer.classList.toggle('show');
      if (backpackContainer.classList.contains('show')) {
        game.updateBackpack();
      }
    }

    sendBtn.addEventListener('click', () => {
      if (!messageInput.disabled && messageInput.value.trim()) {
        const input = messageInput.value.trim();
        game.handleInput(input);
      }
    });

    messageInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter' && !messageInput.disabled && messageInput.value.trim()) {
        const input = messageInput.value.trim();
        game.handleInput(input);
      }
    });

    backpackBtn.addEventListener('click', toggleBackpack);

    game.goToStage('intro');
  </script>
</body>
</html>
